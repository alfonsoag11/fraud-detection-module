package com.example.FraudDet;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;

import com.example.FraudDet.Entities.Transaction;
import com.jayway.jsonpath.JsonPath;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
public class TransactionControllerTest {
	@Autowired
	private MockMvc mockMvc;

	@Test
	void getAllTransactions() throws Exception {
		this.mockMvc.perform(get("/transactions")).andDo(print()).andExpect(status().isOk())
		.andExpect(jsonPath("$._embedded.transactionList[:1].description").value("Walmart Rio Frio"));
	}

	@Test
	void createTransaction() throws Exception {
		this.mockMvc.perform(
	      post("/transactions")
	      .content(UserControllerTests.asJsonString(new Transaction("Shady e-commerce", 100.01f, Status.COMPLETED, RiskLevel.CRITICAL)))
	      .contentType(MediaType.APPLICATION_JSON)
	      .accept(MediaType.APPLICATION_JSON))
		.andExpect(status().isCreated()) // 201
		.andExpect(jsonPath("$.id").exists()); // The unique id is autogenerated, that's a sign that the entity was succesfully created.
	}

	@Test
	void completeTransaction() throws Exception {
		// First lets create a transaction that can be successfully completed
		MvcResult result = this.mockMvc.perform(
	      post("/transactions")
	      .content(UserControllerTests.asJsonString(new Transaction("Real commerce", 70.10f, Status.IN_PROGRESS, RiskLevel.LOW)))
	      .contentType(MediaType.APPLICATION_JSON)
	      .accept(MediaType.APPLICATION_JSON))
      .andExpect(status().isCreated()) // 201
      .andExpect(jsonPath("$.id").exists())
	  .andReturn();

		int id = JsonPath.read(result.getResponse().getContentAsString(), "$.id");

		this.mockMvc.perform(
			put("/transactions/{id}/complete", id)
			.accept(MediaType.APPLICATION_JSON))
			.andExpect(status().isOk())
			.andExpect(jsonPath("$.status").value(Status.COMPLETED.toString()));
	}

	@Test
	void errorOnCompleteTransaction() throws Exception {
		// First lets create a transaction that can be successfully completed
		MvcResult result = this.mockMvc.perform(
	      post("/transactions")
	      .content(UserControllerTests.asJsonString(new Transaction("Commerce", 80.80f, Status.IN_PROGRESS, RiskLevel.LOW)))
	      .contentType(MediaType.APPLICATION_JSON)
	      .accept(MediaType.APPLICATION_JSON))
      .andExpect(status().isCreated()) // 201
      .andExpect(jsonPath("$.id").exists())
	  .andReturn();

		int id = JsonPath.read(result.getResponse().getContentAsString(), "$.id");
		// We'll complete the transaction so it cannot be completed again
		this.mockMvc.perform(
			put("/transactions/{id}/complete", id)
			.accept(MediaType.APPLICATION_JSON))
			.andExpect(status().isOk())
			.andExpect(jsonPath("$.status").value(Status.COMPLETED.toString()));

		String errorDetails = "You can't complete a transaction that is in the " + Status.COMPLETED.toString() + " status";

		this.mockMvc.perform(
			put("/transactions/{id}/complete", id)
			.accept(MediaType.APPLICATION_PROBLEM_JSON))
			.andExpect(status().isMethodNotAllowed())
			.andExpect(jsonPath("$.detail").value(errorDetails));
		
	}

	@Test
	void cancelTransaction() throws Exception {

		// First lets create a transaction that can be successfully cancelled
		MvcResult result = this.mockMvc.perform(
			post("/transactions")
			.content(UserControllerTests.asJsonString(new Transaction("Automatic payment", 1000.17f, Status.IN_PROGRESS, RiskLevel.CRITICAL)))
			.contentType(MediaType.APPLICATION_JSON)
			.accept(MediaType.APPLICATION_JSON))
		.andExpect(status().isCreated()) // 201
		.andExpect(jsonPath("$.id").exists())
		.andReturn();
	
		int id = JsonPath.read(result.getResponse().getContentAsString(), "$.id");
	
		this.mockMvc.perform(
		delete("/transactions/{id}/cancel", id)
		.accept(MediaType.APPLICATION_JSON))
		.andExpect(status().isOk())
		.andExpect(jsonPath("$.status").value(Status.CANCELLED.toString()));
	}

	@Test
	void errorOnCancelTransaction() throws Exception {
		// A transaction to work with
		MvcResult result = this.mockMvc.perform(
	      post("/transactions")
	      .content(UserControllerTests.asJsonString(new Transaction("Misterious e-commerce", 80.80f, Status.IN_PROGRESS, RiskLevel.HIGH)))
	      .contentType(MediaType.APPLICATION_JSON)
	      .accept(MediaType.APPLICATION_JSON))
      .andExpect(status().isCreated()) // 201
      .andExpect(jsonPath("$.id").exists())
	  .andReturn();

		int id = JsonPath.read(result.getResponse().getContentAsString(), "$.id");
		// We'll cancel the transaction so the second attempt to cancel will fail.
		this.mockMvc.perform(
			delete("/transactions/{id}/cancel", id)
			.accept(MediaType.APPLICATION_JSON))
			.andExpect(status().isOk())
			.andExpect(jsonPath("$.status").value(Status.CANCELLED.toString()));

		String errorDetails = "You can't cancel an order that is in the " + Status.CANCELLED.toString() + " status";

		this.mockMvc.perform(
			delete("/transactions/{id}/cancel", id)
			.accept(MediaType.APPLICATION_PROBLEM_JSON))
			.andExpect(status().isMethodNotAllowed())
			.andExpect(jsonPath("$.detail").value(errorDetails));
	}
}



